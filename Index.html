<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>robringer - 3D Avatar Editor & Games</title>
    <!-- Load Tailwind CSS for utility classes and responsive base -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /*
        * 2012 Roblox Aesthetic CSS Overrides
        */
        :root {
            --roblox-blue: #015B9A;
            --roblox-light-blue: #0076B9;
            --roblox-gray: #EFEFEF;
            --roblox-dark-border: #999;
            --roblox-text-color: #333;
            --roblox-mid-gray: #D0D0D0;
            --roblox-yellow: #FFE23D;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #F8F8F8; 
            color: var(--roblox-text-color);
        }

        /* Header Styling */
        .roblox-header {
            background-color: var(--roblox-light-blue);
            background-image: linear-gradient(to bottom, #008cd6, #0076B9);
            border-bottom: 2px solid #005691;
            padding: 10px 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Button Styling - Classic Blocky Look */
        .roblox-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 14px;
            margin: 0 4px;
            font-size: 14px;
            font-weight: bold;
            color: var(--roblox-text-color);
            background-color: var(--roblox-gray);
            border: 1px solid var(--roblox-dark-border);
            border-radius: 0;
            cursor: pointer;
            box-shadow: 0 1px 0 var(--roblox-dark-border);
            transition: background-color 0.1s;
            text-transform: uppercase;
            white-space: nowrap; /* Prevent text wrap */
        }
        .roblox-button:hover:not(.primary-button):not(.active-button) {
            background-color: #E0E0E0;
        }

        /* Active Button State (Page Indicator) */
        .roblox-button.active-button {
            background-color: var(--roblox-yellow); /* Roblox Yellow */
            color: var(--roblox-text-color);
            border-color: #CDB72F;
            box-shadow: 0 1px 0 #CDB72F;
        }
        .roblox-button.active-button:hover {
            background-color: #FFDC30; 
        }

        /* Primary Blue Button Style */
        .primary-button {
            color: white;
            background-color: var(--roblox-light-blue);
            background-image: linear-gradient(to bottom, #008cd6, #0076B9);
            border-color: var(--roblox-blue);
            box-shadow: 0 2px 0 var(--roblox-blue);
        }

        .primary-button:hover {
            background-image: linear-gradient(to top, #008cd6, #0076B9);
        }

        /* Success/Equipped Button Style (Green) */
        .success-button {
            color: white;
            background-color: #4CAF50; /* Green */
            background-image: linear-gradient(to bottom, #5cb85c, #4CAF50);
            border-color: #3d8b40;
            box-shadow: 0 2px 0 #3d8b40;
        }
        .success-button:hover {
            background-image: linear-gradient(to top, #5cb85c, #4CAF50);
        }

        /* Game Card Styling */
        .game-card-img {
            aspect-ratio: 16 / 9; /* Standard thumbnail aspect ratio */
            width: 100%;
        }

        /* Main Content Container */
        .main-container, .avatar-editor-container {
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background-color: white;
            border: 1px solid var(--roblox-dark-border);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* --- 3D EDITOR STYLES --- */
        #avatar-canvas-container {
            border: 1px solid var(--roblox-dark-border);
            background-color: var(--roblox-mid-gray); /* Light gray background for contrast */
            height: 400px; /* Fixed height for the canvas area */
            width: 100%;
            cursor: grab;
            touch-action: none;
        }
        #avatar-canvas-container:active {
            cursor: grabbing;
        }
        
        .control-box {
            background-color: var(--roblox-gray);
            border: 1px solid var(--roblox-dark-border);
            padding: 10px;
        }
        .color-picker-label {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        
        /* Catalog Item Card */
        .catalog-item-card {
            border: 1px solid var(--roblox-dark-border);
            background-color: white;
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .item-preview {
            height: 120px;
            background-color: var(--roblox-mid-gray);
            border: 1px solid var(--roblox-dark-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--roblox-text-color);
            margin-bottom: 8px;
            font-size: 12px;
            text-align: center;
        }
        
        /* Login Panel/Modal */
        .login-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            padding: 20px;
            background-color: white;
            border: 1px solid var(--roblox-dark-border);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        
        .login-header {
            background-color: var(--roblox-blue);
            color: white;
            font-weight: bold;
            padding: 8px;
            text-align: center;
            margin: -20px -20px 20px -20px;
            border-bottom: 1px solid var(--roblox-dark-border);
        }
        
        .roblox-input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--roblox-dark-border);
            margin-bottom: 15px;
            box-sizing: border-box;
            border-radius: 0;
        }

        .login-button-row {
            display: flex;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .link-button {
            background: none;
            border: none;
            color: var(--roblox-light-blue);
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
    <!-- Firebase Imports for Authentication/Persistence -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            setLogLevel, 
            onSnapshot, 
            collection, 
            addDoc,     
            query       
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase instances (defined in window scope for access by non-module scripts)
        window.app = null;
        window.db = null;
        window.auth = null;
        // Updated default to signal the initialization check is needed
        window.userId = 'uninitialized'; 
        window.username = 'Guest'; 
        
        // This is the current App ID (MANDATORY variable)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Helper function for Firestore document paths
        window.USER_DATA_PATH = (uid) => {
            // Private user profile data 
            return doc(window.db, 'artifacts', appId, 'users', uid, 'user_data', 'profile');
        };
        
        // Path to check for unique usernames (public data)
        const USERNAME_MAP_PATH = (username) => {
            // Path: Col(artifacts)/Doc(appId)/Col(public)/Doc(data)/Col(usernames)/Doc(username.toLowerCase())
            return doc(window.db, 'artifacts', appId, 'public', 'data', 'usernames', username.toLowerCase());
        };
        
        // Public collection for games data
        window.GAMES_COLLECTION_PATH = () => {
            // Path: Col(artifacts)/Doc(appId)/Col(public)/Doc(data)/Col(games)
            return collection(window.db, 'artifacts', appId, 'public', 'data', 'games');
        };

        
        // Function to load user data from Firestore
        window.loadUserData = async (uid) => {
            // Check for DB readiness before attempting to load data
            if (!window.db || !uid || uid === 'loading...' || uid === 'uninitialized') {
                console.warn("Attempted to load user data before DB was ready.");
                return;
            }
            
            try {
                const docRef = window.USER_DATA_PATH(uid);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Update global state
                    window.rowbux = data.rowbux || 100;
                    window.equippedItemIds = new Set(data.equippedItemIds || []);
                    window.username = data.username || 'User' + uid.substring(0, 5); // Load username
                } else {
                    // Handle anonymous/new user creation of default profile
                    window.rowbux = 100; // Default starting robux
                    window.equippedItemIds = new Set();
                    window.username = window.auth.currentUser.isAnonymous ? 
                        'Guest' : 
                        'User' + uid.substring(0, 5); // Default for first login of authenticated user
                        
                    // Only attempt to save a default profile if not anonymous (i.e., we just signed up)
                    if (window.auth.currentUser && !window.auth.currentUser.isAnonymous) {
                         // This will create the initial profile document
                         await window.saveUserData(uid); 
                    }
                }
                
                // CRITICAL: Call the UI update functions (defined in the standard script block)
                if (window.updateRobuxDisplay) window.updateRobuxDisplay(); 
                if (window.updateUsernameDisplay) window.updateUsernameDisplay();
                if (window.updateAvatarAppearance) window.updateAvatarAppearance();
                if (window.renderCatalog) window.renderCatalog();
                
            } catch (error) {
                console.error("Error loading user data:", error);
            }
        };

        // Function to save user data to Firestore
        window.saveUserData = async (uid) => {
            if (!window.db || !uid || uid === 'loading...' || uid === 'uninitialized' || !window.equippedItemIds) {
                console.warn("Save attempted, but DB is not ready or user ID is invalid. Skipping save.");
                return;
            }

            // Ensure state is retrieved from the window global variables
            const dataToSave = {
                username: window.username, // Include username in saved data
                rowbux: window.rowbux,
                equippedItemIds: Array.from(window.equippedItemIds)
            };
            
            try {
                const docRef = window.USER_DATA_PATH(uid);
                // Use setDoc with merge: true to avoid overwriting the whole document
                await setDoc(docRef, dataToSave, { merge: true });
            } catch (error) {
                console.error("Error saving user data:", error);
            }
        };


        // Initialize Firebase
        window.initFirebase = async () => {
            try {
                setLogLevel('Debug'); // Enable Firebase logging
                
                // Safety check for config: if undefined, use an empty object and Firebase init will likely fail,
                // which is handled by the main application logic.
                const firebaseConfigString = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
                let firebaseConfig = {};
                try {
                    firebaseConfig = JSON.parse(firebaseConfigString);
                } catch (e) {
                    console.error("Failed to parse Firebase config JSON:", e);
                    throw new Error("Invalid Firebase Configuration provided.");
                }

                if (Object.keys(firebaseConfig).length === 0) {
                     throw new Error("Empty Firebase Configuration. Running in Offline Guest Mode.");
                }
                
                window.app = initializeApp(firebaseConfig);
                window.db = getFirestore(window.app);
                window.auth = getAuth(window.app);
                
                // Attempt to sign in with custom token
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (initialAuthToken) {
                    await signInWithCustomToken(window.auth, initialAuthToken);
                } else {
                    // Fallback to anonymous sign-in
                    await signInAnonymously(window.auth);
                }

                console.log("Firebase services initialized and auth attempted.");
                return true; // Success

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                window.auth = null; // Ensure auth is null if initialization failed
                return false; // Failure
            }
        };
        
        // Expose auth and firestore functions to the standard script block
        window.USERNAME_MAP_PATH = USERNAME_MAP_PATH;
        window.getDoc = getDoc;
        window.setDoc = setDoc; 
        window.createUserWithEmailAndPassword = createUserWithEmailAndPassword;
        window.signInWithEmailAndPassword = signInWithEmailAndPassword;
        window.onAuthStateChanged = onAuthStateChanged;
        window.doc = doc; 
        window.signOut = signOut; 
        // Expose Firestore functions for games
        window.onSnapshot = onSnapshot;
        window.collection = collection;
        window.addDoc = addDoc;
        window.query = query;

    </script>
</head>
<body class="min-h-screen">

    <!-- --- MESSAGE BOX MODAL (Replaces Alert/Confirm) --- -->
    <!-- The JavaScript will inject the modal here when needed -->
    
    <!-- --- LOGIN PAGE CONTAINER (VISIBLE by default) --- -->
    <div id="login-container" class="login-panel">
        <div class="login-header"><span id="auth-mode-title">robringer User Login</span></div>
        <div class="login-body">
            
            <!-- Error Message Box - Changed background to be more noticeable -->
            <p id="auth-message" class="hidden text-sm text-center p-2 mb-3 bg-red-400 text-white font-bold border border-red-500"></p>

            <!-- Sign Up Fields (Visible in Sign Up Mode) -->
            <div id="signup-fields">
                <label class="block mb-2 text-sm font-semibold" for="username-input">Username:</label>
                <input type="text" id="username-input" class="roblox-input" placeholder="Enter desired username (4+ chars)" required />
            </div>

            <!-- Fields shared by both Login and Sign Up -->
            <label class="block mb-2 text-sm font-semibold" for="email-input">Email:</label>
            <input type="email" id="email-input" class="roblox-input" placeholder="Enter email" required />

            <label class="block mb-2 text-sm font-semibold" for="password">Password:</label>
            <input type="password" id="password" class="roblox-input" placeholder="Enter password (6+ characters)" required />

            <!-- Action Buttons -->
            <div class="login-button-row">
                <button id="auth-action-button" class="roblox-button primary-button w-full">Login</button>
            </div>
            
            <button id="mode-toggle-link" class="link-button w-full text-center mt-2">
                Need an account? Switch to Sign Up
            </button>
            
            <p class="text-xs text-gray-500 mt-4 text-center">
                User: <span id="display-username">loading...</span> | ID: <span id="display-user-id">loading...</span>
            </p>
        </div>
    </div>
    
    <!-- --- MAIN APP UI CONTAINER (HIDDEN by default) --- -->
    <div id="main-ui-container" class="hidden">
        <!-- 2012 Roblox Header -->
        <header class="roblox-header flex justify-between items-center sticky top-0 z-10">
            <h1 class="font-extrabold text-white text-3xl">robringer</h1>
            
            <div class="flex items-center space-x-2">
                <!-- Navigation Buttons -->
                <button class="roblox-button view-button" data-view="home">Home</button>
                <button class="roblox-button view-button" data-view="games">Games</button> <!-- NEW -->
                <button class="roblox-button view-button" data-view="catalog">Catalog</button>
                <button id="avatar-button" class="roblox-button view-button" data-view="avatar">Avatar</button>
                <button class="roblox-button view-button" data-view="upload">Upload</button> <!-- NEW -->
                
                <!-- Robux Action Button -->
                <button id="buy-rowbux-button" class="roblox-button primary-button">BUY ROBUX</button>
                
                <!-- Robux Counter Display -->
                <div id="robux-counter" class="roblox-button cursor-default select-none">
                    <span id="robux-display">R$ 0</span>
                </div>
                
                <!-- User Display -->
                <div class="roblox-button cursor-default select-none bg-gray-200">
                    User: <span id="header-username-display">Guest</span>
                </div>
                
                <!-- Logout Button -->
                <button id="logout-button" class="roblox-button bg-red-400 hover:bg-red-500 text-white border-red-500 box-shadow: 0 1px 0 red">LOGOUT</button>
            </div>
        </header>

        <!-- VIEWS CONTAINER -->
        <div id="views">
            <!-- 1. Home View -->
            <main id="view-home" class="main-container hidden"> 
                <h2>Welcome, <span class="font-bold text-blue-600" id="welcome-username">Guest</span>!</h2>
                <p>You have successfully loaded the application.</p>
                
                <div class="mt-8 p-4 bg-gray-100 border border-gray-400">
                    <h3 class="font-bold mb-2">Account Status:</h3>
                    <p>
                        Your current username is: <strong id="home-username-display" class="text-blue-600">loading...</strong>
                    </p>
                    <p>
                        Your internal account ID is: <strong id="home-user-id-display" class="text-gray-500 text-xs">loading...</strong>
                    </p>
                    <p class="mt-2">
                        <strong id="persistence-status">Your data is currently persistent.</strong>
                    </p>
                </div>

                <div class="mt-8 border-t border-gray-300 pt-4 text-sm text-center text-gray-500">
                    Â© 2025 robringer. All rights reserved. (Retro Edition)
                </div>
            </main>

            <!-- 2. Avatar Editor View -->
            <div id="view-avatar" class="avatar-editor-container hidden">
                <h2 class="text-xl font-bold mb-4">3D Avatar Editor</h2>
                
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                    <!-- 3D Viewport -->
                    <div id="avatar-canvas-container" class="lg:col-span-2">
                        <!-- Three.js Canvas will be appended here -->
                    </div>

                    <!-- Customization Controls -->
                    <div class="control-box space-y-4">
                        <h3 class="font-bold text-lg mb-2 border-b border-gray-400 pb-1">Appearance</h3>
                        
                        <!-- Color Pickers -->
                        <div>
                            <label class="color-picker-label" for="head-color">Head Color:</label>
                            <input type="color" id="head-color" value="#FFE23D" class="w-full h-8" data-part="Head" />
                        </div>
                        <div>
                            <label class="color-picker-label" for="torso-color">Torso Color:</label>
                            <input type="color" id="torso-color" value="#0076B9" class="w-full h-8" data-part="Torso" />
                        </div>
                        <div>
                            <label class="color-picker-label" for="arm-color">Arms Color:</label>
                            <input type="color" id="arm-color" value="#FFE23D" class="w-full h-8" data-part="Arm" />
                        </div>
                        <div>
                            <label class="color-picker-label" for="leg-color">Legs Color:</label>
                            <input type="color" id="leg-color" value="#9C9C9C" class="w-full h-8" data-part="Leg" />
                        </div>
                        
                        <button class="roblox-button primary-button w-full mt-4">Save Avatar</button>
                    </div>
                </div>
            </div>
            
            <!-- 3. Catalog View -->
            <div id="view-catalog" class="main-container hidden">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-300 pb-2">Avatar Item Catalog</h2>
                <div id="catalog-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                    <!-- Items will be injected here by renderCatalog() -->
                </div>
            </div>

            <!-- 4. Games Discovery View (NEW) -->
            <div id="view-games" class="main-container hidden">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-300 pb-2">Games Discovery</h2>
                <div id="games-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                    <!-- Games will be injected here -->
                </div>
            </div>
            
            <!-- 5. Upload/Studio View (NEW) -->
            <div id="view-upload" class="main-container hidden">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-300 pb-2">Create & Upload</h2>
                
                <!-- Studio Download Mock -->
                <div class="p-6 mb-8 control-box bg-blue-100 border-blue-400">
                    <h3 class="font-bold text-lg text-roblox-blue mb-3">robringer Studio</h3>
                    <p class="text-sm mb-4">You need robringer Studio to create and edit your amazing 3D worlds!</p>
                    <button class="roblox-button success-button" onclick="window.displayMessageBox('Studio Download', 'A download for the mock robringer Studio is starting... (Please remember this is a web simulation, no actual files will be downloaded)')">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l2.293-2.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        Download Studio
                    </button>
                </div>
                
                <!-- Game Upload Form -->
                <div class="control-box">
                    <h3 class="font-bold text-lg mb-4 border-b border-gray-400 pb-1">Publish Game Place</h3>
                    <form id="game-upload-form" class="space-y-4">
                        <div>
                            <label class="block mb-1 font-semibold text-sm">Game Title (e.g., Blocky Battle Arena)</label>
                            <input type="text" id="game-title" class="roblox-input" required maxlength="50" />
                        </div>
                        <div>
                            <label class="block mb-1 font-semibold text-sm">Game Description</label>
                            <textarea id="game-description" class="roblox-input" rows="3" required maxlength="250"></textarea>
                        </div>
                        <div>
                            <label class="block mb-1 font-semibold text-sm">Game Image URL (Mock Thumbnail)</label>
                            <input type="url" id="game-image-url" class="roblox-input" required placeholder="https://placehold.co/400x225/333/fff?text=Game+Thumbnail" />
                        </div>
                        
                        <!-- Mock file upload, we only care about metadata. File type is .rblx. -->
                        <div>
                            <label class="block mb-1 font-semibold text-sm">Game File (.rblx mock)</label>
                            <input type="file" id="game-file" class="roblox-input p-1" accept=".rblx, .rbxlx" required />
                        </div>
                        
                        <button type="submit" id="upload-game-button" class="roblox-button primary-button w-full">Publish Game</button>
                    </form>
                    <p id="upload-message" class="mt-4 text-center text-sm hidden"></p>
                </div>
            </div>
        </div>
    </div>


    <script>
        // --- JAVASCRIPT FOR UI, AUTH AND ROBUX COUNTER (Standard Script Block) ---
        
        // UI Elements
        const buyButton = document.getElementById('buy-rowbux-button'); 
        const robuxDisplay = document.getElementById('robux-display');
        const viewButtons = document.querySelectorAll('.view-button');
        const views = document.querySelectorAll('#views > *'); 
        const catalogGrid = document.getElementById('catalog-grid');
        // NEW UI Elements
        const gamesGrid = document.getElementById('games-grid');
        const uploadForm = document.getElementById('game-upload-form');
        const uploadMessage = document.getElementById('upload-message');


        // Login UI Elements
        const loginContainer = document.getElementById('login-container');
        const mainUIContainer = document.getElementById('main-ui-container');
        const authActionButton = document.getElementById('auth-action-button');
        const modeToggleLink = document.getElementById('mode-toggle-link');
        const authModeTitle = document.getElementById('auth-mode-title');
        const signupFields = document.getElementById('signup-fields');

        const usernameInput = document.getElementById('username-input'); 
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password');
        const authMessage = document.getElementById('auth-message');
        const logoutButton = document.getElementById('logout-button');
        
        let isSignupMode = false; // Initial mode is Login

        // --- CATALOG ITEMS DEFINITION ---
        const CATALOG_ITEMS = [
            { id: 'cap', name: 'Cool Red Cap', price: 150, type: 'Hat', color: 0xCC0000,
              geometry: { type: 'Box', size: [1.3, 0.4, 1.3], position: [0, 5.4, 0], previewText: "CAP" } },
            { id: 'shades', name: 'Black Shades', price: 200, type: 'Face', color: 0x333333, 
              geometry: { type: 'Box', size: [1.4, 0.2, 0.2], position: [0, 4.4, 0.61], previewText: "SHADES" } },
            { id: 'wings', name: 'Golden Wings', price: 500, type: 'Back', color: 0xFFD700,
              geometry: { type: 'Box', size: [0.2, 2, 2], position: [0, 3.5, -0.5], previewText: "WINGS" } },
            { id: 'scarf', name: 'Blue Scarf', price: 100, type: 'Neck', color: 0x00AEEF, 
              geometry: { type: 'Box', size: [1.5, 0.2, 0.3], position: [0, 4.0, 0.5], previewText: "SCARF" } }
        ];

        // --- EXPOSE GLOBAL STATE TO THE THREE.JS SCRIPT BLOCK ---
        window.CATALOG_ITEMS = CATALOG_ITEMS;

        // --- VIEW SWITCHING LOGIC ---
        
        // Keep track of the unsubscribe function for the games listener
        let gamesUnsubscribe = null;

        const switchView = (targetViewId) => {
            // 1. Hide all views
            views.forEach(view => {
                view.classList.add('hidden');
            });
            
            // 2. Deactivate all buttons
            viewButtons.forEach(button => {
                button.classList.remove('active-button');
            });

            // 3. Stop the games listener if leaving the games view
            if (gamesUnsubscribe) {
                gamesUnsubscribe();
                gamesUnsubscribe = null;
            }

            // 4. Show the target view
            const targetView = document.getElementById(`view-${targetViewId}`);
            if (targetView) {
                targetView.classList.remove('hidden');
            }
            
            // 5. Activate the corresponding button
            const targetButton = document.querySelector(`.view-button[data-view="${targetViewId}"]`);
            if (targetButton) {
                targetButton.classList.add('active-button');
            }
            
            // 6. Conditional visibility for the BUY ROBUX button
            if (buyButton) {
                // Hide Robux button on Avatar and Upload pages
                buyButton.classList.toggle('hidden', targetViewId === 'avatar' || targetViewId === 'upload');
            }

            // 7. Handle view-specific initialization
            if (targetViewId === 'avatar') {
                if (!window.threeInitialized) {
                    window.initThreeD();
                }
                if (window.onWindowResize) {
                    window.onWindowResize();
                }
            } else if (targetViewId === 'catalog') {
                renderCatalog();
            } else if (targetViewId === 'home') {
                document.getElementById('home-user-id-display').textContent = window.userId;
                document.getElementById('home-username-display').textContent = window.username;
                document.getElementById('welcome-username').textContent = window.username;
                document.getElementById('persistence-status').textContent = window.db ? 'Your data is currently persistent.' : 'You are in Offline Guest Mode. Data will NOT be saved.';
            } else if (targetViewId === 'games') {
                // NEW: Start the real-time listener for games (only if DB is available)
                if (window.db) {
                     renderGamesDiscovery();
                } else {
                    gamesGrid.innerHTML = '<p class="text-center md:col-span-4 p-8 text-red-500 font-bold">Cannot access Games Discovery: Database connection failed. Please log in to a persistent account.</p>';
                }
            }
        };
        window.switchView = switchView; // Expose globally

        viewButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetView = button.getAttribute('data-view');
                switchView(targetView);
            });
        });


        // --- ROBUX & UI LOGIC ---
        
        // Function to update the Robux UI
        const updateRobuxDisplay = () => {
            window.rowbux = window.rowbux || 0; // Ensure rowbux is defined
            robuxDisplay.textContent = `R$ ${window.rowbux.toLocaleString()}`;
        };
        window.updateRobuxDisplay = updateRobuxDisplay; // Expose globally
        
        // Function to update the Username UI
        const updateUsernameDisplay = () => {
            const username = window.username || 'Guest';
            document.getElementById('header-username-display').textContent = username;
            document.getElementById('display-username').textContent = username;
        }
        window.updateUsernameDisplay = updateUsernameDisplay; // Expose globally


        // Function to simulate buying Robux
        const handleBuyRowbux = () => {
            if (!window.db) {
                displayMessageBox('Offline Mode', 'You are in offline mode. Robux purchases are disabled.');
                return;
            }

            const amountToAdd = 500;
            window.rowbux += amountToAdd;
            
            buyButton.textContent = `+${amountToAdd}!`;
            buyButton.disabled = true;

            updateRobuxDisplay();
            renderCatalog(); 
            
            if (window.userId && window.saveUserData) {
                window.saveUserData(window.userId); // Save new balance
            }

            setTimeout(() => {
                buyButton.textContent = 'BUY ROBUX';
                buyButton.disabled = false;
            }, 500);
        };
        
        
        // --- CATALOG LOGIC ---

        const toggleEquipItem = (itemId) => {
            if (!window.db) {
                 displayMessageBox('Offline Mode', 'You are in offline mode. Item management is disabled. Please log in.');
                 return;
            }

            if (!window.auth.currentUser || window.auth.currentUser.isAnonymous) {
                displayMessageBox('Login Required', 'Please log in or sign up to manage your items.');
                return;
            }

            const item = CATALOG_ITEMS.find(i => i.id === itemId);
            if (!item) return;

            const isEquipped = window.equippedItemIds.has(itemId);

            if (isEquipped) {
                // UNEQUIP
                window.equippedItemIds.delete(itemId);
                displayMessageBox('Item Unequipped', `${item.name} has been removed from your avatar.`);
            } else {
                // EQUIP/PURCHASE
                if (window.rowbux >= item.price) {
                    window.rowbux -= item.price; // Deduct price
                    window.equippedItemIds.add(itemId);
                    displayMessageBox('Item Equipped!', `${item.name} has been purchased and equipped.`);
                } else {
                    displayMessageBox('Insufficient Robux', `You need ${item.price - window.rowbux} more R$ to purchase ${item.name}!`);
                    return; 
                }
            }
            
            // Save state and update UI
            if (window.userId && window.saveUserData) {
                window.saveUserData(window.userId); 
            }
            updateRobuxDisplay();
            if (window.updateAvatarAppearance) {
                window.updateAvatarAppearance();
            }
            renderCatalog(); // Re-render catalog to update equipped status
        };

        const renderCatalog = () => {
            if (!catalogGrid) return;

            catalogGrid.innerHTML = ''; // Clear previous items

            CATALOG_ITEMS.forEach(item => {
                // For offline/guest mode, assume 100 R$ and all items are 0 R$ to allow customization
                const currentRowbux = window.rowbux || 0;
                const price = window.db ? item.price : 0; 
                const isEquipped = window.equippedItemIds.has(item.id);
                const canAfford = currentRowbux >= price;
                
                const buttonClasses = isEquipped 
                    ? 'success-button' 
                    : (canAfford ? 'primary-button' : 'roblox-button opacity-50 cursor-not-allowed');
                
                let buttonText;
                if (isEquipped) {
                    buttonText = 'Unequip';
                } else if (!window.db) {
                    // Offline mode always shows 'Equip (Offline)'
                    buttonText = 'Equip (Offline)'; 
                } else {
                    buttonText = canAfford ? `Equip (${item.price} R$)` : `Too Expensive`;
                }

                const itemHtml = `
                    <div class="catalog-item-card">
                        <div class="item-preview">${item.name}<br/>(${item.type})</div>
                        <p class="font-bold text-sm mb-2 truncate">${item.name}</p>
                        <button 
                            id="item-${item.id}"
                            class="roblox-button ${buttonClasses} w-full text-xs"
                            data-item-id="${item.id}"
                            ${!canAfford && !isEquipped && window.db ? 'disabled' : ''}
                        >
                            ${buttonText}
                        </button>
                    </div>
                `;
                catalogGrid.insertAdjacentHTML('beforeend', itemHtml);
            });
        };
        window.renderCatalog = renderCatalog;

        // --- GAMES DISCOVERY LOGIC ---

        const renderGamesDiscovery = () => {
            if (!window.db || !gamesGrid) return;
            
            // Unsubscribe from previous listener if it exists
            if (gamesUnsubscribe) {
                gamesUnsubscribe();
            }

            const gamesRef = window.GAMES_COLLECTION_PATH();
            const gamesQuery = window.query(gamesRef); // Fetch all games

            // Set up the real-time listener
            gamesUnsubscribe = window.onSnapshot(gamesQuery, (snapshot) => {
                gamesGrid.innerHTML = ''; // Clear existing content
                
                if (snapshot.empty) {
                    gamesGrid.innerHTML = '<p class="text-center md:col-span-4 p-8 text-gray-500">No games have been published yet. Be the first!</p>';
                    return;
                }

                snapshot.forEach((doc) => {
                    const game = doc.data();
                    const gameId = doc.id;
                    
                    // Placeholder image handling with error fallback
                    const imageUrl = game.imageUrl || 'https://placehold.co/400x225/333/fff?text=No+Image';

                    const gameCardHtml = `
                        <div class="catalog-item-card h-full justify-start">
                            <img 
                                src="${imageUrl}" 
                                class="game-card-img object-cover border-b border-gray-400 mb-2" 
                                onerror="this.onerror=null; this.src='https://placehold.co/400x225/333/fff?text=Image+Load+Error';"
                                alt="${game.title} thumbnail"
                            />
                            <h3 class="font-bold text-sm truncate mb-1">${game.title}</h3>
                            <p class="text-xs text-gray-600 mb-2">Creator: ${game.ownerUsername || 'Unknown'}</p>
                            <p class="text-xs italic mb-4 line-clamp-2">${game.description || 'No description provided.'}</p>
                            <button 
                                data-game-id="${gameId}" 
                                class="roblox-button primary-button mt-auto w-full text-sm"
                                onclick="window.handlePlayGame('${game.title.replace(/'/g, "\\'")}', '${game.ownerUsername.replace(/'/g, "\\'")}')"
                            >
                                Download Game (.rblx)
                            </button>
                        </div>
                    `;
                    gamesGrid.insertAdjacentHTML('beforeend', gameCardHtml);
                });
            }, (error) => {
                console.error("Error fetching games:", error);
                gamesGrid.innerHTML = '<p class="text-center md:col-span-4 p-8 text-red-500">Error loading games. Please check the console.</p>';
            });
        };
        window.renderGamesDiscovery = renderGamesDiscovery; // Expose globally

        // Function for playing a game to trigger a file download
        window.handlePlayGame = (title, creator) => {
            // 1. Define mock file content (JSON structure mimicking a game place file)
            const mockContent = {
                version: "robringer.v1.rblx",
                title: title,
                creator: creator || 'Anonymous',
                objects: [
                    { type: "Baseplate", material: "Grass", size: [512, 1, 512] },
                    { type: "SpawnLocation", position: [0, 2, 0] },
                    { type: "Part", position: [5, 5, 5], color: [255, 0, 0] }
                ],
                message: "This is a mock game place file to demonstrate the .rblx download feature."
            };
            
            // Create a safe filename
            const safeTitle = title.replace(/[^a-z0-9]/gi, '_');
            const safeCreator = (creator || 'Unknown').replace(/[^a-z0-9]/gi, '_');
            const filename = `${safeTitle}_by_${safeCreator}.rblx`;
            const jsonContent = JSON.stringify(mockContent, null, 2);

            // 2. Create a Blob
            const blob = new Blob([jsonContent], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);

            // 3. Create a temporary <a> tag and trigger download
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            // 4. Clean up the object URL
            URL.revokeObjectURL(url);
            
            // 5. Notify user of download start
            window.displayMessageBox('Download Started', `The game file for **${title}** has started downloading as **${filename}**.`);
        };


        // --- GAME UPLOAD LOGIC ---
        const handleGameUpload = async (e) => {
            e.preventDefault();
            
            if (!window.db || !window.auth.currentUser || window.auth.currentUser.isAnonymous) {
                uploadMessage.textContent = 'You must be logged in to a persistent account to publish a game.';
                uploadMessage.className = 'mt-4 text-center text-sm text-red-500 font-bold';
                uploadMessage.classList.remove('hidden');
                return;
            }

            const button = document.getElementById('upload-game-button');
            button.disabled = true;
            button.textContent = 'Publishing...';
            uploadMessage.classList.add('hidden');
            
            const title = document.getElementById('game-title').value.trim();
            const description = document.getElementById('game-description').value.trim();
            const imageUrl = document.getElementById('game-image-url').value.trim();
            const fileInput = document.getElementById('game-file');
            const file = fileInput.files[0];
            
            // Simple validation
            if (!title || !description || !imageUrl || !file) {
                uploadMessage.textContent = 'Please fill out all fields, including the mock game file.';
                uploadMessage.className = 'mt-4 text-center text-sm text-red-500 font-bold';
                uploadMessage.classList.remove('hidden');
                button.disabled = false;
                button.textContent = 'Publish Game';
                return;
            }
            
            const newGame = {
                title: title,
                description: description,
                imageUrl: imageUrl,
                ownerId: window.userId,
                ownerUsername: window.username, // Uses the globally loaded username
                createdAt: Date.now(),
                // Mocking file size and type
                fileSize: file.size, 
                fileName: file.name
            };

            try {
                // Add the game metadata to the public 'games' collection
                const docRef = await window.addDoc(window.GAMES_COLLECTION_PATH(), newGame);
                
                uploadMessage.textContent = `Game "${title}" published successfully! ID: ${docRef.id}`;
                uploadMessage.className = 'mt-4 text-center text-sm text-green-600 font-bold';
                uploadMessage.classList.remove('hidden');
                
                // Clear form inputs
                document.getElementById('game-title').value = '';
                document.getElementById('game-description').value = '';
                document.getElementById('game-image-url').value = '';
                fileInput.value = null; // Clear file input

                // Switch to games view to show the new game (will auto-refresh via onSnapshot)
                window.switchView('games');
                
            } catch (error) {
                console.error("Error publishing game:", error);
                uploadMessage.textContent = `Error publishing game: ${error.message}`;
                uploadMessage.className = 'mt-4 text-center text-sm text-red-500 font-bold';
                uploadMessage.classList.remove('hidden');
            } finally {
                button.disabled = false;
                button.textContent = 'Publish Game';
            }
        };

        // --- MESSAGE BOX UTILITY (Replaces alert() and confirm()) ---
        const displayMessageBox = (title, message) => {
            const modalHtml = `
                <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[2000]">
                    <div class="login-panel p-0">
                        <div class="login-header">${title}</div>
                        <div class="p-4 text-sm">
                            <p class="mb-4">${message}</p>
                            <button class="roblox-button primary-button float-right" onclick="document.getElementById('message-modal').remove()">OK</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        };
        window.displayMessageBox = displayMessageBox; // Expose globally

        // --- AUTHENTICATION LOGIC ---

        const toggleAuthMode = () => {
            isSignupMode = !isSignupMode;
            authModeTitle.textContent = isSignupMode ? "robringer User Sign Up" : "robringer User Login";
            authActionButton.textContent = isSignupMode ? "Sign Up" : "Login";
            modeToggleLink.textContent = isSignupMode ? "Already have an account? Switch to Login" : "Need an account? Switch to Sign Up";
            
            // Toggle visibility of username field for signup
            signupFields.style.display = isSignupMode ? 'block' : 'none';
            
            // Clear inputs and messages
            authMessage.classList.add('hidden');
            usernameInput.value = '';
            emailInput.value = '';
            passwordInput.value = '';
        };

        const handleAuthSuccess = async (user, username) => {
            // Update the global userId
            window.userId = user.uid;
            
            // If a username was passed (meaning successful signup), update global state immediately
            if (username) {
                window.username = username;
            }

            // Update display immediately (UID is always available)
            document.getElementById('display-user-id').textContent = window.userId;

            // Load data (which fetches the username and updates the UI, or creates the profile if new)
            await window.loadUserData(user.uid);

            // Hide login UI and show main UI
            loginContainer.classList.add('hidden');
            mainUIContainer.classList.remove('hidden');

            // Set default view
            switchView('home'); 
        };

        const handleAuthError = (action, error) => {
            // Map Firebase error codes to user-friendly messages
            let errorMessage = "An unknown error occurred.";
            
            if (error && error.code) {
                console.error(`${action} failed:`, error.code, error.message);

                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "This email is already registered. Please log in or use a different email.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email format.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Password must be at least 6 characters long.";
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid email or password.";
                } else if (error.code === 'username/already-taken') {
                    errorMessage = "The chosen username is already taken. Please choose another.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Network error. Please check your connection and try again.";
                } else if (error.code === 'permission-denied' || error.message.includes('permission-denied')) {
                     errorMessage = "Signup failed due to a temporary permissions issue. Please try again or use Login if you already created the account.";
                } else {
                     errorMessage = error.message;
                }
            } else {
                 console.error(`${action} failed with non-Firebase error:`, error);
            }
            
            authMessage.textContent = errorMessage;
            authMessage.classList.remove('hidden');

            // Restore button state
            authActionButton.textContent = action;
            authActionButton.disabled = false;
        };
        
        // Main handler for Login/Signup action button
        const handleAuthAction = async () => {
            const action = isSignupMode ? "Sign Up" : "Login";
            authMessage.classList.add('hidden');
            authActionButton.disabled = true;
            authActionButton.textContent = action.toUpperCase() === 'SIGN UP' ? "CREATING ACCOUNT..." : "LOGGING IN...";
            
            // IMPORTANT: If DB is not available, block the user from attempting persistent auth
            if (!window.db) {
                handleAuthError(action, { message: "Cannot connect to the database. Persistent login/signup is disabled." });
                return;
            }

            try {
                if (isSignupMode) {
                    await attemptSignup();
                } else {
                    await attemptLogin();
                }
            } catch (error) {
                // All specific errors are handled within attemptSignup/Login, 
                // but this catch ensures any unhandled error restores the button.
                handleAuthError(action, error);
            } finally {
                // Button state is restored via handleAuthError or after successful transition
            }
        };


        const attemptLogin = async () => {
            const email = emailInput.value.trim();
            const password = passwordInput.value;

            if (!email || !password) {
                return handleAuthError('Login', { message: "Please enter both email and password." });
            }
            
            try {
                const userCredential = await window.signInWithEmailAndPassword(window.auth, email, password);
                await handleAuthSuccess(userCredential.user);
                authActionButton.textContent = "Login"; // Only restore text, as UI will transition
            } catch (error) {
                throw error; // Let the main catch block handle the UI restore
            }
        };

        const attemptSignup = async () => {
            const username = usernameInput.value.trim();
            const email = emailInput.value.trim();
            const password = passwordInput.value;

            if (!username || username.length < 4 || username.includes('@') || !email || password.length < 6) {
                return handleAuthError('Sign Up', { message: "Please ensure username is 4+ chars (no @), email is valid, and password is 6+ chars." });
            }
            
            try {
                // 1. Check for username uniqueness in Firestore (Public data)
                authActionButton.textContent = "CHECKING USERNAME...";
                const usernameDocRef = window.USERNAME_MAP_PATH(username);
                const usernameSnap = await window.getDoc(usernameDocRef);
                
                if (usernameSnap.exists()) {
                    throw { code: 'username/already-taken' }; // Custom code for handling
                }
                
                // 2. Create Firebase user using the provided EMAIL (This also logs the user in)
                authActionButton.textContent = "CREATING ACCOUNT...";
                const userCredential = await window.createUserWithEmailAndPassword(window.auth, email, password);
                const user = userCredential.user;
                
                // 3. CRITICAL: Force token refresh to ensure permissions are up to date
                authActionButton.textContent = "SYNCHRONIZING PERMISSIONS...";
                await user.getIdToken(true); 
                const currentUid = window.auth.currentUser.uid;

                // 4. Save the public username mapping with RETRY LOGIC for robustness
                authActionButton.textContent = "SAVING USERNAME MAP...";
                let retryCount = 0;
                const MAX_RETRIES = 3;
                const BASE_DELAY_MS = 500;
                let publicWriteSuccessful = false;

                while (retryCount < MAX_RETRIES) {
                    try {
                        // Path: /artifacts/{appId}/public/data/usernames/{username}
                        await window.setDoc(usernameDocRef, { 
                            uid: currentUid, 
                            email: email, 
                            createdAt: new Date().toISOString() 
                        }, { merge: true });
                        
                        publicWriteSuccessful = true;
                        break; // Success, exit retry loop

                    } catch (writeError) {
                        retryCount++;
                        console.warn(`Attempt ${retryCount} failed on public write:`, writeError.message);
                        
                        if (retryCount >= MAX_RETRIES) {
                            // On failure, log the error but allow user to proceed (they have a Firebase account)
                            console.error("CRITICAL WARNING: Failed to write public username map after multiple attempts. User can still proceed with account created.");
                            break; 
                        }
                        
                        // Exponential backoff
                        const delay = BASE_DELAY_MS * Math.pow(2, retryCount - 1);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                
                // 5. Handle success.
                await handleAuthSuccess(user, username);
                
                // Toggle mode back to Login (UI hidden)
                toggleAuthMode(); 
                authActionButton.textContent = "Sign Up"; 

            } catch (error) {
                // IMPORTANT: Throw the error object so handleAuthError can process the code.
                throw error; 
            }
        };


        const handleLogout = async () => {
            if (window.auth && window.signOut) {
                // Save current state before logging out (important for guest data)
                if (window.userId && window.saveUserData && window.db) {
                     await window.saveUserData(window.userId);
                }
                
                if (window.auth.currentUser && !window.auth.currentUser.isAnonymous) {
                    // Only sign out if they are a real user
                    await window.signOut(window.auth);
                } else {
                    // For anonymous users, just reload the page/force the fallback
                    window.location.reload();
                }
                
                // onAuthStateChanged will handle the UI reset
            } else {
                 window.location.reload();
            }
        };


        // --- INITIALIZATION ---

        const initializeApp = async () => {
            // 1. Initialize Firebase services. This sets window.app, window.db, window.auth
            const isFirebaseInitialized = await window.initFirebase(); 
            
            if (isFirebaseInitialized && window.auth) {
                // 2. If Auth service is ready, set up the official listener
                window.onAuthStateChanged(window.auth, (user) => {
                    if (user) {
                        // User is signed in (authenticated or anonymous)
                        window.userId = user.uid;
                        
                        // If the user is authenticated (not anonymous), show the main app
                        if (!user.isAnonymous) {
                             // Authenticated user: Load data and show main UI
                             window.loadUserData(user.uid);
                             loginContainer.classList.add('hidden');
                             mainUIContainer.classList.remove('hidden');
                             switchView('home');
                        } else {
                             // Anonymous user: forces login screen to prompt sign up
                             window.loadUserData(user.uid); // Load guest data if available
                             loginContainer.classList.remove('hidden');
                             mainUIContainer.classList.add('hidden');
                        }
                    } else {
                        // User is signed out (e.g., after logout)
                        window.userId = crypto.randomUUID();
                        window.username = 'Guest';
                        updateUsernameDisplay();
                        loginContainer.classList.remove('hidden');
                        mainUIContainer.classList.add('hidden');
                    }
                    
                    document.getElementById('display-user-id').textContent = window.userId;
                });
            } else {
                // 3. Fallback: Firebase failed to initialize (e.g., blocked or bad config).
                console.error("Firebase Auth initialization failed. Running in forced Guest Mode.");
                
                // Set necessary globals to a default state to unblock UI
                window.userId = crypto.randomUUID();
                window.username = 'Guest (Offline)';
                window.rowbux = 100; // Give some starter cash
                window.equippedItemIds = new Set();
                window.db = null; // Explicitly set DB to null to block DB-dependent operations
                window.auth = null; // Explicitly set Auth to null
                
                // Update UI elements immediately
                updateUsernameDisplay();
                updateRobuxDisplay();
                document.getElementById('display-user-id').textContent = window.userId;
                
                // Force UI transition to the main app as an unauthenticated user
                loginContainer.classList.add('hidden');
                mainUIContainer.classList.remove('hidden');
                
                // Set default view
                switchView('home'); 
                
                // Add a message to inform the user
                window.displayMessageBox('Offline Mode', 'Firebase connection failed. You are running in **Offline Guest Mode**. Data will not be saved, and persistent login/signup/upload is disabled.');
            }

            // Set up event listeners 
            if (buyButton) buyButton.addEventListener('click', handleBuyRowbux);
            if (logoutButton) logoutButton.addEventListener('click', handleLogout);
            if (modeToggleLink) modeToggleLink.addEventListener('click', toggleAuthMode);
            if (authActionButton) { authActionButton.addEventListener('click', handleAuthAction); }
            if (uploadForm) { uploadForm.addEventListener('submit', handleGameUpload); } 
            
            // Use event delegation for catalog buttons
            if (catalogGrid) { 
                catalogGrid.addEventListener('click', (e) => {
                    const button = e.target.closest('.roblox-button');
                    const itemId = button ? button.getAttribute('data-item-id') : null;
                    if (itemId) {
                        toggleEquipItem(itemId);
                    }
                });
            }
            
            // Initialize auth mode display (sets it to Login mode)
            toggleAuthMode();
            toggleAuthMode();
        };

        // Attach listeners after the document is loaded
        document.addEventListener('DOMContentLoaded', initializeApp);


        // --- THREE.JS 3D AVATAR EDITOR LOGIC (Accessing global state via window) ---
        
        if (typeof THREE === 'undefined') {
            console.error("Three.js library is not loaded.");
        } else {
            window.threeInitialized = false;

            let scene, camera, renderer, avatarGroup, accessoryGroup;
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            // Store references to the avatar parts' materials for easy color updating
            const avatarParts = {}; 

            // Configuration for the rounded R15-style avatar dimensions
            const AVATAR_CONFIG = {
                Head: { type: 'Sphere', size: [0.6], center: [0, 4.6, 0], color: 0xFFE23D, partType: 'Head' }, 
                Torso: { type: 'Capsule', size: [0.5, 1.0], center: [0, 3.0, 0], color: 0x0076B9, partType: 'Torso' }, 
                LeftArm: { type: 'Capsule', size: [0.3, 1.4], center: [-1.0, 3.0, 0], color: 0xFFE23D, partType: 'Arm' },
                RightArm: { type: 'Capsule', size: [0.3, 1.4], center: [1.0, 3.0, 0], color: 0xFFE23D, partType: 'Arm' },
                LeftLeg: { type: 'Capsule', size: [0.3, 1.4], center: [-0.5, 1.0, 0], color: 0x9C9C9C, partType: 'Leg' },
                RightLeg: { type: 'Capsule', size: [0.5, 1.4], center: [0.5, 1.0, 0], color: 0x9C9C9C, partType: 'Leg' },
            };
            
            /**
             * Creates a geometry composed of a cylinder and two spheres (a capsule shape).
             */
            const createCapsule = (radius, length, color) => {
                const material = new THREE.MeshPhongMaterial({ color: color });
                
                // 1. Cylinder (the body of the capsule)
                const cylinder = new THREE.Mesh(
                    new THREE.CylinderGeometry(radius, radius, length, 16),
                    material
                );
                
                // 2. Top Sphere (caps the top end)
                const sphereRadius = radius;
                const topSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(sphereRadius, 16, 16),
                    material
                );
                topSphere.position.y = length / 2;

                // 3. Bottom Sphere (caps the bottom end)
                const bottomSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(sphereRadius, 16, 16),
                    material
                );
                bottomSphere.position.y = -length / 2;

                const capsuleGroup = new THREE.Group();
                capsuleGroup.add(cylinder, topSphere, bottomSphere);
                
                return { group: capsuleGroup, material: material };
            };


            // Function to create one body part 
            const createPart = (name, config) => {
                let meshOrGroup, material, geometry;
                
                if (config.type === 'Sphere') {
                    geometry = new THREE.SphereGeometry(config.size[0], 32, 16); 
                    material = new THREE.MeshPhongMaterial({ color: config.color }); 
                    meshOrGroup = new THREE.Mesh(geometry, material);
                } else if (config.type === 'Capsule') {
                    const radius = config.size[0];
                    const length = config.size[1];
                    const capsuleData = createCapsule(radius, length, config.color);
                    meshOrGroup = capsuleData.group;
                    material = capsuleData.material;
                } else {
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = new THREE.MeshPhongMaterial({ color: config.color });
                    meshOrGroup = new THREE.Mesh(geometry, material);
                }

                const pivot = new THREE.Group();
                pivot.add(meshOrGroup);
                
                pivot.position.set(config.center[0], config.center[1], config.center[2]);
                
                meshOrGroup.userData = { name, type: config.partType || name };
                avatarParts[name] = material;
                
                return { pivot, mesh: meshOrGroup };
            };


            // Function to refresh equipped items on the avatar
            const updateAvatarAppearance = () => {
                if (!accessoryGroup || !window.CATALOG_ITEMS || !window.equippedItemIds) return;

                // 1. Clear existing accessories
                while(accessoryGroup.children.length > 0){
                    accessoryGroup.remove(accessoryGroup.children[0]); 
                }

                // 2. Add currently equipped items by checking the global state
                window.CATALOG_ITEMS.filter(item => window.equippedItemIds.has(item.id)).forEach(item => {
                    const accessoryMesh = createAccessory(item);
                    if (accessoryMesh) {
                        accessoryGroup.add(accessoryMesh);
                    }
                });
            };
            window.updateAvatarAppearance = updateAvatarAppearance;

            // Function to create an accessory mesh
            const createAccessory = (item) => {
                if (!item || !item.geometry) return null;

                const config = item.geometry;
                let geometry, material;

                if (config.type === 'Box') {
                    geometry = new THREE.BoxGeometry(...config.size);
                } else {
                    return null; 
                }
                
                material = new THREE.MeshPhongMaterial({ color: item.color });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(config.position[0], config.position[1], config.position[2]);
                
                return mesh;
            };


            // Initializes the 3D scene
            const initThreeD = () => {
                const container = document.getElementById('avatar-canvas-container');
                if (!container || window.threeInitialized) return;
                
                window.threeInitialized = true;
                
                // 1. Scene and Renderer
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xd0d0d0);
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                // 2. Camera (Perspective)
                camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
                camera.position.set(5, 5, 5);
                camera.lookAt(0, 2.5, 0); 
                
                // 3. Lighting
                const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.7); 
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.5);
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);

                // 4. Create Avatar Base
                avatarGroup = new THREE.Group();
                
                for (const key in AVATAR_CONFIG) {
                    const { pivot } = createPart(key, AVATAR_CONFIG[key]);
                    avatarGroup.add(pivot);
                }
                
                accessoryGroup = new THREE.Group();
                avatarGroup.add(accessoryGroup);

                scene.add(avatarGroup);
                
                // 5. Add Ground Plane
                const planeGeometry = new THREE.PlaneGeometry(10, 10);
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x808080, side: THREE.DoubleSide });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = Math.PI / 2;
                plane.position.y = 0; 
                scene.add(plane);
                
                // 6. Setup Interaction and Animate
                setupMouseControls(container);
                setupColorControls();
                updateAvatarAppearance(); // Load initial items
                animate();

                // Attach resize handler 
                window.addEventListener('resize', onWindowResize);
                window.onWindowResize = onWindowResize; // Expose to module script
            };

            const onWindowResize = () => {
                const container = document.getElementById('avatar-canvas-container');
                if (!container || !window.threeInitialized) return;

                if (container.offsetWidth > 0 && container.offsetHeight > 0) {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }
            };

            const setupMouseControls = (element) => {
                const onDown = (clientX, clientY) => {
                    isDragging = true;
                    previousMousePosition = { x: clientX, y: clientY };
                };
                
                const onMove = (clientX, clientY) => {
                    if (!isDragging) return;
                    
                    const deltaX = clientX - previousMousePosition.x;
                    avatarGroup.rotation.y += deltaX * 0.005; 
                    
                    previousMousePosition = { x: clientX, y: clientY };
                };

                element.addEventListener('mousedown', (e) => onDown(e.clientX, e.clientY), false);
                element.addEventListener('touchstart', (e) => onDown(e.touches[0].clientX, e.touches[0].clientY), false);
                element.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY), false);
                element.addEventListener('touchmove', (e) => onMove(e.touches[0].clientX, e.touches[0].clientY), false);
                document.addEventListener('mouseup', () => { isDragging = false; }, false);
                document.addEventListener('touchend', () => { isDragging = false; }, false);
            };

            const setupColorControls = () => {
                const colorPickers = document.querySelectorAll('input[type="color"][data-part]');
                colorPickers.forEach(picker => {
                    picker.addEventListener('input', (e) => {
                        const newColor = new THREE.Color(e.target.value);
                        const partType = e.target.getAttribute('data-part');

                        for (const name in AVATAR_CONFIG) {
                            if (AVATAR_CONFIG[name].partType === partType || name === partType) {
                                if (avatarParts[name]) {
                                    avatarParts[name].color.set(newColor);
                                }
                            }
                        }
                    });
                });
            };

            // Main Animation Loop
            const animate = () => {
                requestAnimationFrame(animate);
                if (!isDragging) {
                     avatarGroup.rotation.y += 0.005; 
                }
                renderer.render(scene, camera);
            };

            window.initThreeD = initThreeD;
        }
    </script>
</body>
</html>
